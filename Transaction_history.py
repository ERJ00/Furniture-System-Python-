# -*- coding: utf-8 -*-
import os
import subprocess
from datetime import datetime


# Form implementation generated from reading ui file 'Transaction_history.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QTableWidgetItem

from CustomerData import CustomerData
from Encryption import Encryption


class Ui_transactionHistory(object):
    def setupUi(self, transactionHistory):
        transactionHistory.setObjectName("transactionHistory")
        transactionHistory.resize(1000, 500)
        transactionHistory.setMinimumSize(QtCore.QSize(1000, 500))
        transactionHistory.setMaximumSize(QtCore.QSize(1000, 500))
        self.tableWidget = QtWidgets.QTableWidget(transactionHistory)
        self.tableWidget.setGeometry(QtCore.QRect(10, 70, 981, 411))
        font = QtGui.QFont()
        font.setFamily("Tahoma")
        font.setPointSize(12)
        self.tableWidget.setFont(font)
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        self.label_3 = QtWidgets.QLabel(transactionHistory)
        self.label_3.setGeometry(QtCore.QRect(10, 20, 981, 41))
        self.label_3.setStyleSheet("color: rgb(255, 255, 255);\n"
"font: 75 24pt \"Perpetua Titling MT\";")
        self.label_3.setAlignment(QtCore.Qt.AlignCenter)
        self.label_3.setObjectName("label_3")
        self.pushButton = QtWidgets.QPushButton(transactionHistory)
        self.pushButton.setGeometry(QtCore.QRect(10, 10, 50, 50))
        self.pushButton.setMinimumSize(QtCore.QSize(50, 50))
        self.pushButton.setMaximumSize(QtCore.QSize(50, 50))
        self.pushButton.setAcceptDrops(False)
        self.pushButton.setStyleSheet("background-color: rgba(255, 255, 255, 0);")
        self.pushButton.setText("")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("image/Back_button.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton.setIcon(icon)
        self.pushButton.setIconSize(QtCore.QSize(50, 50))
        self.pushButton.setObjectName("pushButton")
        self.label = QtWidgets.QLabel(transactionHistory)
        self.label.setGeometry(QtCore.QRect(0, 0, 1001, 500))
        self.label.setStyleSheet("background-image: url(Image/BG2.jpg);")
        self.label.setText("")
        self.label.setObjectName("label")
        self.label.raise_()
        self.tableWidget.raise_()
        self.label_3.raise_()
        self.pushButton.raise_()

        # Add a combo box for selecting the month
        self.comboBox = QtWidgets.QComboBox(transactionHistory)
        self.comboBox.setGeometry(QtCore.QRect(820, 20, 151, 22))
        self.comboBox.setObjectName("comboBox")
        self.comboBox.addItems(["All", "January", "February", "March", "April", "May", "June", "July", "August",
                                "September", "October", "November", "December"])

        # Connect the combo box signal to the sorting function
        self.comboBox.currentIndexChanged.connect(self.display_table)

        # Add a combo box for selecting the status
        self.comboBoxStatus = QtWidgets.QComboBox(transactionHistory)
        self.comboBoxStatus.setGeometry(QtCore.QRect(70, 20, 151, 22))
        self.comboBoxStatus.setObjectName("comboBoxStatus")
        self.comboBoxStatus.addItems(["All", "Balance", "Paid"])

        # Connect the combo box signal to the sorting function
        self.comboBoxStatus.currentIndexChanged.connect(self.display_table)

        self.retranslateUi(transactionHistory)
        QtCore.QMetaObject.connectSlotsByName(transactionHistory)

        self.pushButton.clicked.connect(self.backToMain)

    def retranslateUi(self, transactionHistory):
        _translate = QtCore.QCoreApplication.translate
        transactionHistory.setWindowTitle(_translate("transactionHistory", "Transaction History"))
        self.label_3.setText(_translate("transactionHistory", "transaction history"))

    customer = []

    def add_item(self,data):
        self.customer.append(data)

    def retrieve(self):
        file_path = "Database/transaction_history.txt"  # Replace with the actual file path

        try:
            with open(file_path, "r") as reader:
                for line in reader:
                    line = Encryption.decrypt(line)
                    arr_line = line.split(" / ")

                    if len(arr_line) < 14:
                        print("Invalid line format:", line)
                        continue  # Skip this line and proceed to the next iteration

                    temp = CustomerData()  # Create a new instance for each item

                    try:
                        temp.setStatus(arr_line[0].strip())
                        temp.setName(arr_line[1].strip())
                        temp.setBirthday(arr_line[2].strip())
                        temp.setContactNumber(arr_line[3].strip())
                        temp.setAddress(arr_line[4].strip())
                        temp.setProductName(arr_line[5].strip())
                        temp.setCategory(arr_line[6].strip())
                        temp.setQuantity(int(arr_line[7].strip()))
                        temp.setTotalPayment(int(arr_line[8].strip()))
                        temp.setPaymentReceived(int(arr_line[9].strip()))
                        temp.setBalance(int(arr_line[10].strip()))
                        temp.setChange(int(arr_line[11].strip()))
                        temp.setDate(arr_line[12].strip())
                        temp.setID(int(arr_line[13].strip()))
                    except ValueError as e:
                        # Handle the exception gracefully (e.g., log the error, skip the item, etc.)
                        print("Error parsing data:", str(e))
                        continue  # Skip this item and proceed to the next iteration

                    self.add_item(temp)
        except IOError as e:
            print("Error reading file:", e)

    def display_table(self):
        selected_month = self.comboBox.currentText()
        selected_status = self.comboBoxStatus.currentText()

        self.tableWidget.clear()

        # Filter the data based on the selected month and status
        filtered_items = []

        if selected_month == "All" and selected_status == "All":
            filtered_items = self.customer
        elif selected_month == "All":
            if selected_status == "Balance":
                filtered_items = [item for item in self.customer if item.balance > 0]
            elif selected_status == "Paid":
                filtered_items = [item for item in self.customer if item.balance == 0]
        elif selected_status == "All":
            filtered_items = [item for item in self.customer if
                              datetime.strptime(item.date, "%Y-%m-%d").strftime("%B") == selected_month]
        else:
            if selected_status == "Balance":
                filtered_items = [item for item in self.customer if
                                  datetime.strptime(item.date, "%Y-%m-%d").strftime("%B") == selected_month
                                  and item.balance > 0]
            elif selected_status == "Paid":
                filtered_items = [item for item in self.customer if
                                  datetime.strptime(item.date, "%Y-%m-%d").strftime("%B") == selected_month
                                  and item.balance == 0]

        num_rows = len(filtered_items)
        num_cols = 13

        # Set the table dimensions
        self.tableWidget.setRowCount(num_rows)
        self.tableWidget.setColumnCount(num_cols)

        # Define the desired attribute names
        attribute_names = [
            "status", "name", "birthday", "contactNumber", "address", "productName",
            "category", "quantity", "totalPayment", "paymentReceived", "balance", "change", "date"]
        self.tableWidget.setHorizontalHeaderLabels(attribute_names)

        if num_rows == 0:
            # Display "No data available" message
            table_item = QTableWidgetItem("No data available")
            table_item.setTextAlignment(QtCore.Qt.AlignCenter)
            table_item.setFlags(QtCore.Qt.ItemIsEnabled)
            self.tableWidget.setItem(0, 0, table_item)
            self.tableWidget.setSpan(0, 0, 1, num_cols)
        else:
            # Populate the table with data
            for row, item in enumerate(filtered_items):
                for col in range(num_cols):
                    attribute_name = attribute_names[col]
                    value = getattr(item, attribute_name)
                    table_item = QTableWidgetItem(str(value))

                    # Set the item flags to make it read-only
                    table_item.setFlags(QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable)

                    self.tableWidget.setItem(row, col, table_item)

        # Adjust column widths to maximize space
        self.tableWidget.resizeColumnsToContents()

    def backToMain(self):
        transactionHistory.destroy()
        current_directory = os.path.dirname(os.path.abspath(__file__))
        script_path = os.path.join(current_directory, "main.py")
        subprocess.run(["python", script_path])

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    transactionHistory = QtWidgets.QFrame()
    ui = Ui_transactionHistory()
    ui.setupUi(transactionHistory)
    ui.retrieve()
    ui.display_table()
    transactionHistory.show()
    sys.exit(app.exec_())
